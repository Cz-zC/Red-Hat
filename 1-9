q	Linux进程管理
q	ps| top| pgrep| pstree| netstat工具的使用方式
q	虚拟文件系统 /proc 、/sys
q	LINUX后台进程与前台进程
q	进程的优先级管理
q	文件控制台的窗口管理

Linux进程管理
    早期的DOS操作是单用户操作系统，WIN XP 是单用户多任务操作系统，LINUX,UNIX是多用户多任务操作系统；WIN 7是多用户操作系统，WIN SERVER 2003\2008\2012是多用户多任务操作系统
 程序、进程、线程概念
程序：一组指令及参数的集合。它是做为一个静态文件存储在硬盘中
进程：程序的执行就是进程，也就是说进程是运行着的程序。也可以把进程看成一个独立的程序，在内存中有其对应的代码空间和数据空间，一个进程所拥有的数据和代码只属于自己(make –j 4)。进程是资源分配的基本单位，也是调度运行的基本单位。
线程：线程被人们认为是轻量级的进程，它是进程中单独运行的程序。是处理器调度的最小单元
换句话说，就是一个进程可以包含多个线程，并且至少有一个主线程，同时同一进程的线程共享该进程的代码和数据。

 

n	程序和进程的区别
	1、程序是静态的，它只是一组指令的集合，不具有任何的运行意义。本身作为一次软件资源长期保存；而进程是程序执行的动态过程.它是动态概念，有一定的生命周期，它是动态产生和消亡的
	2、 进程和程序并不是一一对应的关系，相同的程序运行在不同的数据集上就是不同的进程；一个程序可以由多个进程公用
	3、进程还具有并发性和交往性，而程序却是封闭的。
n	进程和线程的区别
	1、一个进程可以拥有多个线程，而一个线程同时只能被一个进程所拥有。
	2、线程不能单独执行，但是每一个线程都有程序的入口、执行序列以及程序出口。它必须组成进程才能被执行。
进程的属性
进程ID（PID)：是唯一的数值，用来区分进程
父进程的ID（PPID)
启动进程的用户ID（UID）和所归属的组（GID）
进程状态：状态分为运行R、休眠S、僵尸Z
进程执行的优先级
进程所连接的终端名
进程资源占用：比如占用资源大小（内存、CPU占用量）

进程管理工具
对于Linux进程的管理，是通过进程管理工具实现的，比如ps、kill、工具
进程查看命令：ps
常用参数（选项）
q	-a	显示所有用户的进程
q	-u	显示用户名和启动时间
q	-x	显示没有控制终端的进程
q	-e	显示所有进程，包括没有控制终端的进程
q	-l	长格式显示，详细信息显示
q	-w  宽行显示，可以使用多个w进行加宽显示


BSD----> ps aux （Unix）    GNU---->ps lax（Linux）   POSIX---> ps -ef

我们常用的选项是组合是aux
查看隶属于自己进程详细信息
 



查看进程：ps -aux
 


只显示前十行：ps -aux | head -10

 
另一种显示：ps -ef | head -10
 

第三种显示方法：ps -lax | head -10

 


参数的解释
ps -aux|head -10
USER    PID   %CPU   %MEM    VSZ   RSS  TTY  STAT START   TIME COMMAND
 
UID	用户的id	   
USER	用户名	   
PID	进程号	   
PPID	父进程的进程号	   
VSZ	进程的虚拟大小	   
RSS	驻留集的大小，也可以理解为内存中页的数量	   
TTY	进程启动的终端	   
STAT	进程当前状态（S休眠状态，D不可中断的休眠状态，R运行状态，Z僵死状态，T停止）	   
NI	进程优先级	   
TIME	进程自从启动以后启用CPU的总时间	   
%CPU	占用CPU时间和总时间的百分比	   
%MEM	占用内存与系统内存总量的百分比	   
COMMAND/CMD	进程的命令名	 


其中状态参数说明：
 
<	高优先级	   
N	低优先级	   
L	有些页被锁进内存	   
S	包含子进程	   
+	前台的进程组	   
l	多线程	 
 top动态查看进程
动态查看进程信息：top
他会一直刷新

 
前五行是系统整体的统计信息。
系统的信息解释
任务队列信息(第一行)
 
 
其内容如下：
 
17：21：32	当前时间	   
up2：33	系统运行时间，格式为时:分	   
2 users,	当前登录用户数	   
load average: 0.02, 0.04, 0.07	系统负载，即任务队列的平均长度。 三个数值分别为  1分钟、5分钟、15分钟前到现在的平均值。	 

进程和CPU的信息( 第二、三行)
 
当有多个CPU时，这些内容可能会超过两行。内容如下：
 
Tasks: 481 total	进程M总数	   
1 running	正在运行的进程数	   
480 sleeping	睡眠的进程数	   
0 stopped	停止的进程数	   
0 zombie	僵尸进程数	   
Cpu(s): 
0.0% us	系统用户进程使用CPU百分比。 	   
0.0% sy	内核中的进程占用CPU百分比	   
0.0% ni	用户进程空间内改变过优先级的进程占用CPU百分比	   
100% id	空闲CPU百分比	 
内存信息(第四五行)
 
内容如下：
 
Mem: 2033552k total	物理内存总量	 
  
340392k used	使用的物理内存总量	   
1376636k free	空闲内存总量	   
316524k buff/cache	用作内核缓存的内存量。
和free –k 一个意思
 
	   
Swap: 2017948k total	交换区总量	   
0k used	使用的交换区总量	   
192772k free	空闲交换区总量	   
1518148 avail Mem	总的可利用内存是多少	 
进程信息
 

 
列名	含义	   
PID	进程id	   
USER	进程所有者的用户名	   
PR	优先级（由内核动态调整），用户不能	   
NI	进程优先级。 nice值。负值表示高优先级，正值表示低优先级，用户可以自己调整	   
VIRT（virtual memory usage）	虚拟内存，是进程正在使用的所有内存（ps中标为VSZ）	   
RES（resident memory usage）	是进程所使用的物理内存。实际实用内存（ps中标为RSS）	   
SHR	共享内存大小，单位kb	   
S	进程状态。
            D=不可中断的睡眠状态
            R=运行中或可运行
            S=睡眠中
            T=已跟踪/已停止
            Z=僵停	   
%CPU	上次更新到现在的CPU时间占用百分比	   
%MEM	进程使用的物理内存百分比	   
TIME+	进程使用的CPU时间总计，单位1/100秒	   
COMMAND	命令名/命令行	 
top快捷键：
q	默认3s刷新一次，按d / s修改刷新时间
q	w：保存配置
q	空格 ：立即刷新。
q	q退出
q	M：按内存排序
q	u/U：指定显示的用户
q	P：按CPU排序
q	h:帮助
另一种查看进程的方法：htop


 

pgrep管理工具
作用:查找服务进程号
语法格式 pgrep  [服务名称]
比如我们查看一下httpd服务的进程号

 




 pstree工具使用
pstree命令以树状图显示进程间的关系（display a tree of processes）。
格式：pstree
以树状图显示进程，只显示进程的名字，且相同进程合并显示。
格式：pstree  -p
以树状图显示进程，还显示进程PID。
 

使用netstat工具
netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 
命令参数：

q	-a或–all 显示所有连接中的接口
q	-c或–continuous 持续列出网络状态
q	-C或–cache 显示路由器配置的快取信息
q	-e或–extend 显示网络其他相关信息
q	-F或–fib 显示FIB
q	-g或–groups 显示多重广播功能群组组员名单
q	-h或–help 在线帮助
q	-i或–interfaces 显示网络界面信息表单
q	-l或–listening 显示监控中的服务器的接口
q	-M或–masquerade 显示伪装的网络连线
q	-n或–numeric 直接使用IP地址，而不通过域名服务器
q	-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称
q	-o或–timers 显示计时器
q	-p或–programs 显示正在使用接口的程序识别码和程序名称
q	-r或–route 显示Routing Table
q	-s或–statistice 显示网络工作信息统计表
q	-t或–tcp 显示TCP传输协议的连接状况
q	-u或–udp 显示UDP传输协议的连接状况
q	-v或–verbose 显示指令执行过程
q	-V或–version 显示版本信息
q	-w或–raw 显示RAW传输协议的连线状况
q	-x或–unix 此参数的效果和指定”-A unix”参数相同
q	–ip或–inet 此参数的效果和指定”-A inet”参数相同

查看所有的TCP端口
查看端口被谁占用：netstat -anutp | grep 80

 

n	查看某个服务的端口
netstat -anutp | grep sshd
 
n	查看所有的UDP端口
netstat -anlpu

 


 虚拟文件系统 /proc 、/sys
Linux一切皆文件，设备（文件）可以通过读写来操作
	/proc是内存中有关系统进程的信息
	/sys是有关系统内核以及驱动的信息
 

 

n	查看当前CPU信息
 

n	查看当前内存的信息
 

n	开启内核转发功能
	如果我们使用iptables服务，要设置一些Ip转发、限制等，那么我们的Linux是可以作为一台路由器来使用的，我们可以通过设置参数来开启它的路由转发功能，然后再iptables中进行相应的配置
例如：
[root@qiaolima  ~]# echo "1" >/proc/sys/net/ipv4/ip_forward
[root@qiaolima  ~]# cat  /proc/sys/net/ipv4/ip_forward
1

vip(virtual IP) 
arp(地址解析)
Linux后台进程与前台进程
Linux后台进程与前台进程的区别
Linux后台进程:
	也叫守护进程（Daemon），是运行在后台的一种特殊进程。
	守护的意思就是不受终端控制；Linux的大多数服务器就是用守护进程实现的。
比如，Web服务器httpd等。
Linux前台进程:
	用户使用的有控制终端的进程.
进程的前台与后台运行
跟系统任务相关的几个命令：fg、bg、jobs、（nohup）&、ctrl+z
 
&	用在一个命令的最后，可以把这个命令放到后台执行.	   
ctrl + z	 将一个正在前台执行的命令放到后台，并且暂停.	   
jobs	查看当前有多少在后台运行的进程.		   
fg	 将后台中的命令调至前台继续运行, 如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)  	   
bg	将一个在后台暂停的命令，变成继续执行; 如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)	 
实战恢复被挂起的进程
 

那么怎么恢复呢？用bg还是fg
用fg会回将后台命令调到前台运行
 


而用bg，是将后台暂停的命令变成继续运行
 
通过jobs查看当前正在运行的后台命令
通过后面加数字，例如：fg 1 
转入1的后台命令中。

 


kill进程
控制（关闭）进程
kill用法
关闭进程：kill  [进程号]
通过信号的方式来控制进程
 
kill -19     相当于crtl+z
kill -2     相当于crtl+c
实战:kill和killall终止进程
查看 进程的pid
使用kill命令
 

进程的优先级管理
进程的优先级的定义  1000 1500 ------------------------》
一个进程正好有40种不同级别的NICE值，值越高，优先级越低
优先级取值范围为（-20,19），越小优先级越高, 默认优先级是0
系统允许ROOT用户设置负nice级别以及降低现有进程的nice级别；对普通非特权用户仅允许设置正的nice级别，此外，他们只能对现有进程提升nice级别。而不能降低nice级别
注意：在linux中除了nice级别以外，有很多方法可以影响到进程优先级和资源使用情况，比如备用的调度程序策略和设置、控制组等，但是nice级别是里面最易于使用的一种方法，而且它不仅系统管理员可以使用，普通用户也可以使用
命令1：nice
作用:指定程序的运行优先级
格式：nice -n command
命令2：renice
作用:改变程序的运行优先级
格式：renice -n pid
实战：
n	指定一个文件的优先级

 
输入内容，然后ctrl+z 挂起
n	通过ps查看这个文件的PID号
 ps -aux|grep vim
 
n	通过top命令查看优先级
top -p 3175
 

 

n	改变正在运行的进程的优先级
 

 
或者在top命令中输入r
 

 


文件控制台的窗口管理
screen 实战后台实时执行命令
1、安装screen软件包
yum -y install screen
2、什么是screen?
Screen中有会话的概念,，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。
直接在命令行键入screen命令回车

举例：
创建一个名为hello的screen：
screen -S hello
在这个新屏幕里面：vim 1.txt
如果这时候下班了，ctrl+a 然后按d
屏幕会被保留下来
到家了如果在想运行，就恢复即可:
screen -r hello


